{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ChalkBot Note This is an admonition Description of the project ChalkBot.","title":"ChalkBot"},{"location":"#chalkbot","text":"Note This is an admonition Description of the project ChalkBot.","title":"ChalkBot"},{"location":"Diet%20Pi/","text":"Diet Pi Benefits In the process of work, we came across another version of the operating system, which could facilitate the process of developing our application in a fairly detailed form. We present to your attention the operating system Diet Pi, which has a number of advantages over Raspberry Pi. It is an extremely lightweight Debian OS, highly optimised for minimal CPU and RAM resource usage, ensuring your SBC always runs at its maximum potential. There several benefits of using Diet Pi: Minimalist Linux distribution for single-board computers As few packages as possible \u2192 fast startup Comes without a GUI by default Install desired software on first boot Simple operation via SSH SSH works out of the box Smaller RAM consumption than Raspberry Pi OS Above all, users can quickly and easily backup or restore their DietPi system. Using the DietPi-Services Control, user can control which installed software has higher or lower priority levels: nice, affinity, policy scheduler and more. Within the DietPi-Automation the user can completely automate a DietPi installation with no user input. Simply by configuring dietpi.txt before powering on. Welcome screen after the connection over SSH: It takes 25s approximately for booting of the DietPi, which is more quick than the result of the RaspberryPi with 40s. Installation of DietPi OS Please download the DietPi OS using the following link .","title":"Diet Pi"},{"location":"Diet%20Pi/#diet-pi","text":"","title":"Diet Pi"},{"location":"Diet%20Pi/#benefits","text":"In the process of work, we came across another version of the operating system, which could facilitate the process of developing our application in a fairly detailed form. We present to your attention the operating system Diet Pi, which has a number of advantages over Raspberry Pi. It is an extremely lightweight Debian OS, highly optimised for minimal CPU and RAM resource usage, ensuring your SBC always runs at its maximum potential. There several benefits of using Diet Pi: Minimalist Linux distribution for single-board computers As few packages as possible \u2192 fast startup Comes without a GUI by default Install desired software on first boot Simple operation via SSH SSH works out of the box Smaller RAM consumption than Raspberry Pi OS Above all, users can quickly and easily backup or restore their DietPi system. Using the DietPi-Services Control, user can control which installed software has higher or lower priority levels: nice, affinity, policy scheduler and more. Within the DietPi-Automation the user can completely automate a DietPi installation with no user input. Simply by configuring dietpi.txt before powering on. Welcome screen after the connection over SSH: It takes 25s approximately for booting of the DietPi, which is more quick than the result of the RaspberryPi with 40s.","title":"Benefits"},{"location":"Diet%20Pi/#installation-of-dietpi-os","text":"Please download the DietPi OS using the following link .","title":"Installation of DietPi OS"},{"location":"Gamepad%20Input%20Script/","text":"Gamepad Input Script Inputs Python Library As a basis for developing our application, we use the Inputs Python Library . The reason was the incredible flexibility and wide range of possibilities of this resource and a good feedback about the work from the community. All necessary information about the library can be pulled out of the following pages: github/inputs zeth/inputs There are several reasons for using exactly this library: The Inputs module provides Python programs with an easy way to listen for user input. Currently supported platforms are Linux (including Raspberry Pi and Chromebooks in developer mode), Windows and the Apple Mac. Supported Python versions are all versions of Python 3 and Python 2.7 Inputs is in pure Python and there are no Raspberry Pi, Linux or Windows dependencies. It is also very useful when the device needs to run a particular application in full screen mode, but you would like to listen in the background for a certain set of user data, e.g. to bring up the admin panel in digital signage settings. But the most suffcient feature of the Iputs module is taht it is cross-platform, so it doesn't matter which you use, the event data will be normalized and your program will work the same on the other operating system. Installation $ pip install inputs or directly from source $ git clone https://github.com/zeth/inputs.git $ cd inputs $ python setup.py install As a concept of connecting the Gamepad controller with the Raspberry Pi within the ChalkBot Framework we used the following architecture: We observe the connection with the USB Gamepad Dongle via wireless connection, the default requierement is to have the dongle preliminarily on the device. Te commands are being sent from the Raspberry Pi using wireless connection to the ESP-Module. Implementation Written in Python Uses the ChalkBot Library 2 threads ( Gamepad thread & Network Communication Thread ) Configuration via Config File and Command Line possible Logging with different levels in file Gamepad thread The reason we implemented multiple threads had several benefits as it is listed below: Support for any controller, one mapping per controller Support for multiple control schemes \u2013 What happens if there are conflicting inputs? So e.g. forwards and backwards at the same time Maximum value is used \u2013 Inputs Library does not support hotplug, i.e. USB dongle must be used with program start Network Communication Thread sends the current Drive Instructions to the ChalkBot every 100 ms with the ChalkBot Library. Error handling reacts differently in various cases: if a thread has an exception, sends exit event it also ends the other thread, if it can if it doesn't, it will be forced to quit Program flow plan Flowing charts depicts the threading and decion making of the module by creating the associated object and sending instruction for the event. Handling of exceptions are also part of the default workflow. Core behavior Here under we observe the typical functional behavior of the implementation: Systemd / Autostart Image was taken from www.systemd.io Systemd is a tool of basic building blocks for a Linux system. It provides a system and service manager that runs as PID 1 and starts the rest of the system. Systemd provides parallelization, uses socket and D-Bus activation for starting services, offers on-demand starting of daemons, keeps track of processes using Linux control groups, maintains mount and automount points, and implements an elaborate transactional dependency-based service control logic. systemd supports SysV and LSB init scripts and works as a replacement for sysvinit, starts first program running at boot, manages programs via services, it is actually the init process, i.e. PID 1,of a Linux system. After starting and running the application the system reads the services written in the unit file of the program. The script takes configuration from config file (/etc/default/chalkbot/gamepad_controller.conf).","title":"Gamepad Input Script"},{"location":"Gamepad%20Input%20Script/#gamepad-input-script","text":"","title":"Gamepad Input Script"},{"location":"Gamepad%20Input%20Script/#inputs-python-library","text":"As a basis for developing our application, we use the Inputs Python Library . The reason was the incredible flexibility and wide range of possibilities of this resource and a good feedback about the work from the community. All necessary information about the library can be pulled out of the following pages: github/inputs zeth/inputs There are several reasons for using exactly this library: The Inputs module provides Python programs with an easy way to listen for user input. Currently supported platforms are Linux (including Raspberry Pi and Chromebooks in developer mode), Windows and the Apple Mac. Supported Python versions are all versions of Python 3 and Python 2.7 Inputs is in pure Python and there are no Raspberry Pi, Linux or Windows dependencies. It is also very useful when the device needs to run a particular application in full screen mode, but you would like to listen in the background for a certain set of user data, e.g. to bring up the admin panel in digital signage settings. But the most suffcient feature of the Iputs module is taht it is cross-platform, so it doesn't matter which you use, the event data will be normalized and your program will work the same on the other operating system.","title":"Inputs Python Library"},{"location":"Gamepad%20Input%20Script/#installation","text":"$ pip install inputs or directly from source $ git clone https://github.com/zeth/inputs.git $ cd inputs $ python setup.py install As a concept of connecting the Gamepad controller with the Raspberry Pi within the ChalkBot Framework we used the following architecture: We observe the connection with the USB Gamepad Dongle via wireless connection, the default requierement is to have the dongle preliminarily on the device. Te commands are being sent from the Raspberry Pi using wireless connection to the ESP-Module.","title":"Installation"},{"location":"Gamepad%20Input%20Script/#implementation","text":"Written in Python Uses the ChalkBot Library 2 threads ( Gamepad thread & Network Communication Thread ) Configuration via Config File and Command Line possible Logging with different levels in file Gamepad thread The reason we implemented multiple threads had several benefits as it is listed below: Support for any controller, one mapping per controller Support for multiple control schemes \u2013 What happens if there are conflicting inputs? So e.g. forwards and backwards at the same time Maximum value is used \u2013 Inputs Library does not support hotplug, i.e. USB dongle must be used with program start Network Communication Thread sends the current Drive Instructions to the ChalkBot every 100 ms with the ChalkBot Library. Error handling reacts differently in various cases: if a thread has an exception, sends exit event it also ends the other thread, if it can if it doesn't, it will be forced to quit","title":"Implementation"},{"location":"Gamepad%20Input%20Script/#program-flow-plan","text":"Flowing charts depicts the threading and decion making of the module by creating the associated object and sending instruction for the event. Handling of exceptions are also part of the default workflow.","title":"Program flow plan"},{"location":"Gamepad%20Input%20Script/#core-behavior","text":"Here under we observe the typical functional behavior of the implementation:","title":"Core behavior"},{"location":"Gamepad%20Input%20Script/#systemd-autostart","text":"Image was taken from www.systemd.io Systemd is a tool of basic building blocks for a Linux system. It provides a system and service manager that runs as PID 1 and starts the rest of the system. Systemd provides parallelization, uses socket and D-Bus activation for starting services, offers on-demand starting of daemons, keeps track of processes using Linux control groups, maintains mount and automount points, and implements an elaborate transactional dependency-based service control logic. systemd supports SysV and LSB init scripts and works as a replacement for sysvinit, starts first program running at boot, manages programs via services, it is actually the init process, i.e. PID 1,of a Linux system. After starting and running the application the system reads the services written in the unit file of the program. The script takes configuration from config file (/etc/default/chalkbot/gamepad_controller.conf).","title":"Systemd / Autostart"},{"location":"PS2%20Controls%20-%20Hardware/","text":"PS2 controls through Arduino - Hardware Side Below is a detailed documentation of the hardware components used to enable PS2 controls of the ChalkBot. This information is subject to change, for example, Arduino Mega will eventually replaced by the lighter Arduino Nano, etc. The controller This project uses Blue Lake Performance Wireless PS2 Controller. The receiver component can connect to the target device through USB or classic PS2 pins. Controller connection to Arduino Mega Jumper wires have been used to connect the pins on PS2 receiver to the Arduino Mega: The receiver is fully powered through Arduino Mega through the corresponding pin, but this will not be possible in the later stages of the project, since Arduino Nano is unable to power up the receiver. Below is a visual breakdown of the receiver pins for the PS2 controller: Arduino Mega connection to PC Arduino Mega is connected to the PC through the USB port, which serves to power it up, as well as enable the serial input received by the Arduino to be read on the PC.","title":"PS2 controls through Arduino - Hardware Side"},{"location":"PS2%20Controls%20-%20Hardware/#ps2-controls-through-arduino-hardware-side","text":"Below is a detailed documentation of the hardware components used to enable PS2 controls of the ChalkBot. This information is subject to change, for example, Arduino Mega will eventually replaced by the lighter Arduino Nano, etc.","title":"PS2 controls through Arduino - Hardware Side"},{"location":"PS2%20Controls%20-%20Hardware/#the-controller","text":"This project uses Blue Lake Performance Wireless PS2 Controller. The receiver component can connect to the target device through USB or classic PS2 pins.","title":"The controller"},{"location":"PS2%20Controls%20-%20Hardware/#controller-connection-to-arduino-mega","text":"Jumper wires have been used to connect the pins on PS2 receiver to the Arduino Mega: The receiver is fully powered through Arduino Mega through the corresponding pin, but this will not be possible in the later stages of the project, since Arduino Nano is unable to power up the receiver. Below is a visual breakdown of the receiver pins for the PS2 controller:","title":"Controller connection to Arduino Mega"},{"location":"PS2%20Controls%20-%20Hardware/#arduino-mega-connection-to-pc","text":"Arduino Mega is connected to the PC through the USB port, which serves to power it up, as well as enable the serial input received by the Arduino to be read on the PC.","title":"Arduino Mega connection to PC"},{"location":"PS2%20Controls%20-%20Software/","text":"PS2 controls through Arduino - Software Side Below is the documentation of the software side of things. This will get updated as the project moves forward. The Arduino Sketch The Arduino sketch allows the Arduino to read the inputs that the PS2 Controller receives. The sketch uses the Arduino PS2 Library - PS2X_lib. The inputs of the PS2 Controller received serially by the Arduino, can be observed from the Serial Monitor of Arduino IDE, since our sketch instructs Arduino to print lines according to the inputs. The Python Program The python program \"ps2_control.py\" responsible for receiving the input and sending it to the Chalkbot itself, or the simulator. The serial library is imported, since it allows us to receive serial input. The serial instance - serialInst stores the serial data. This data is later read line by line as a part of the while loop. D-pad buttons up and down are responsible for forward and backward acceleration respectively. D-pad buttons left and right are responsible for left and right rotation of the Chalkbot. Currently, the program uses the drive() function of the robot to perform these actions. Actions initiated by pressing the D-pad buttons are done at the PWM determined by the pwm variable which is 50 initially. This value can be increased and decreased with the use of R2 and L2 buttons respectively.","title":"PS2 Controls   Software"},{"location":"PS2%20Controls%20-%20Software/#ps2-controls-through-arduino-software-side","text":"Below is the documentation of the software side of things. This will get updated as the project moves forward.","title":"PS2 controls through Arduino - Software Side"},{"location":"PS2%20Controls%20-%20Software/#the-arduino-sketch","text":"The Arduino sketch allows the Arduino to read the inputs that the PS2 Controller receives. The sketch uses the Arduino PS2 Library - PS2X_lib. The inputs of the PS2 Controller received serially by the Arduino, can be observed from the Serial Monitor of Arduino IDE, since our sketch instructs Arduino to print lines according to the inputs.","title":"The Arduino Sketch"},{"location":"PS2%20Controls%20-%20Software/#the-python-program","text":"The python program \"ps2_control.py\" responsible for receiving the input and sending it to the Chalkbot itself, or the simulator. The serial library is imported, since it allows us to receive serial input. The serial instance - serialInst stores the serial data. This data is later read line by line as a part of the while loop. D-pad buttons up and down are responsible for forward and backward acceleration respectively. D-pad buttons left and right are responsible for left and right rotation of the Chalkbot. Currently, the program uses the drive() function of the robot to perform these actions. Actions initiated by pressing the D-pad buttons are done at the PWM determined by the pwm variable which is 50 initially. This value can be increased and decreased with the use of R2 and L2 buttons respectively.","title":"The Python Program"},{"location":"Problems%20%26%20Solving/","text":"Problems & Solving Outline As in any work, in ours everything was not entirely smooth and at times there were problems of various kinds that required a timely solution. At the same time, decisions should be within the clearly defined framework of the project itself, as well as respect for the competent allocation of resources. All problems can be divided into the following three groups: SSH Git WiFi SSH During the project we came across the error message while connecting the device over SSH, which was at some point a bit frustrative, since we couldn't figure out, what the error was caused. After several times of debugging, \"stackoverlow\"-ing and googling on different community forums, we found a way to solve the issue.There are actually three ways of solving the ssh error issue - desktop configuration, terminal configuration and systemctl . In case of desktop configuration, we should just go to the preferences and choose the Raspberry Pi configuration dialog. The next step is to go to the interfaces and click the ssh enabled , if it was not enabled before. For terminal configuration we use well-known command: $ sudo raspi config Then choose the Interfacing Options on the dialog, subsequently navigating to the SSH and choosing OK. The last but not least was the SSH service systemctl $ sudo systemctl enable ssh $ sudo systemctl start ssh For headless Raspberry Pi we have also a solution: so we need to adjust the SSH file in Boot Partiotion of SD-Card, place the username & password . This procedure enables the SSH per default. After enabling the SSH we need to establish the connection, but previously we need get also the ip-address of our Raspberry Pi. For the further connection we need just to type this command in the terminal: $ ssh pi@<IP> Instead of IP we need to put out ip-address of the Raspberry Pi. You are now remotely connected to the Raspberry Pi and can execute commands. Git As in every project nowadays we used the version control system based on git- tool and came across some permission error, that didn't let us push the changes from current files to the remote one. There was also some error message we received: The solution was revealed after some help from the team leader and that was associated with Windows Credential Manager, where some pre-configured settings blocked the push to the remote repository. After deleting these settings everything worked. WiFi Issues There was also some problem with Raspberry Pi Zero WiFi, it was exceptionally poor when the device was moved. The problem had also the backdraw of using HTTP to communicate with ESP. Even if TCP connection is reused, one request takes 7 TCP packets, which means 70 packets per second. However, on the ChalkBot with the ESP, the connection seems quite stable, but should be best replaced with a wired connection. We have investigated this particular isuue in a detailed manner and for that purpose we've measure the transfer rate between the Rasperry Pi and the computer. Interval is 0.1 s, so a total of 10 seconds, so the one can observe clearly to see where the Raspberry Pi is moving. Outlook Switching ESP HTTP Server to support subsequently persistent connection Change communication protocol Avoid TCP connection, as there is too much overhead and FlowControl is undesirable (UDP e.g) This automatically eliminates HTTP Change config on the fly","title":"Problems & Solving"},{"location":"Problems%20%26%20Solving/#problems-solving","text":"","title":"Problems &amp; Solving"},{"location":"Problems%20%26%20Solving/#outline","text":"As in any work, in ours everything was not entirely smooth and at times there were problems of various kinds that required a timely solution. At the same time, decisions should be within the clearly defined framework of the project itself, as well as respect for the competent allocation of resources. All problems can be divided into the following three groups: SSH Git WiFi","title":"Outline"},{"location":"Problems%20%26%20Solving/#ssh","text":"During the project we came across the error message while connecting the device over SSH, which was at some point a bit frustrative, since we couldn't figure out, what the error was caused. After several times of debugging, \"stackoverlow\"-ing and googling on different community forums, we found a way to solve the issue.There are actually three ways of solving the ssh error issue - desktop configuration, terminal configuration and systemctl . In case of desktop configuration, we should just go to the preferences and choose the Raspberry Pi configuration dialog. The next step is to go to the interfaces and click the ssh enabled , if it was not enabled before. For terminal configuration we use well-known command: $ sudo raspi config Then choose the Interfacing Options on the dialog, subsequently navigating to the SSH and choosing OK. The last but not least was the SSH service systemctl $ sudo systemctl enable ssh $ sudo systemctl start ssh For headless Raspberry Pi we have also a solution: so we need to adjust the SSH file in Boot Partiotion of SD-Card, place the username & password . This procedure enables the SSH per default. After enabling the SSH we need to establish the connection, but previously we need get also the ip-address of our Raspberry Pi. For the further connection we need just to type this command in the terminal: $ ssh pi@<IP> Instead of IP we need to put out ip-address of the Raspberry Pi. You are now remotely connected to the Raspberry Pi and can execute commands.","title":"SSH"},{"location":"Problems%20%26%20Solving/#git","text":"As in every project nowadays we used the version control system based on git- tool and came across some permission error, that didn't let us push the changes from current files to the remote one. There was also some error message we received: The solution was revealed after some help from the team leader and that was associated with Windows Credential Manager, where some pre-configured settings blocked the push to the remote repository. After deleting these settings everything worked.","title":"Git"},{"location":"Problems%20%26%20Solving/#wifi-issues","text":"There was also some problem with Raspberry Pi Zero WiFi, it was exceptionally poor when the device was moved. The problem had also the backdraw of using HTTP to communicate with ESP. Even if TCP connection is reused, one request takes 7 TCP packets, which means 70 packets per second. However, on the ChalkBot with the ESP, the connection seems quite stable, but should be best replaced with a wired connection. We have investigated this particular isuue in a detailed manner and for that purpose we've measure the transfer rate between the Rasperry Pi and the computer. Interval is 0.1 s, so a total of 10 seconds, so the one can observe clearly to see where the Raspberry Pi is moving.","title":"WiFi Issues"},{"location":"Problems%20%26%20Solving/#outlook","text":"Switching ESP HTTP Server to support subsequently persistent connection Change communication protocol Avoid TCP connection, as there is too much overhead and FlowControl is undesirable (UDP e.g) This automatically eliminates HTTP Change config on the fly","title":"Outlook"},{"location":"Raspberry%20Pi%20configuration/","text":"Configuration Raspberry Pi SSH Connection Configuration using command line: To open the configuration tool on a Raspberry Pi, enter the following command line in the command prompt: $ sudo raspi config Scroll up and down using tab-key and arrows, navigate SSH then YES , then OK then click Finish . Configuration using desktop: Go to menu Preferences , choosing Raspberry Pi configuration . Then the corresponding GUI opens with setting options, you should select SSH via interface options and release the corresponding option. Images were taken from www.raspberrypi.org Configuration using systemctl: $ sudo systemctl enable ssh $ sudo systemctl start ssh IP-address of Rapsberry Pi You'll need to write down your Raspberry Pi's IP address to connect to it later. The ifconfig command displays information about the current network status, including the IP address, or you can use hostname -I to display the IP addresses associated with the device. For connection with the Raspberry Pi you need to type in the following: $ sudo pi@<IP> WiFi Connection The tool raspi-config is being used also for the configuration of the wireless network to various parts of the boot, login, and networking process, as well as some other system-level changes. Wireless LAN connection is also turned on via this application as well as SSH. The one can also configure country-specific WLAN connection via WLAN Country if it's needed. VNC on Raspberry Pi In case someone likes to work on Raspberry Pi from another device by remote control, or when it is not convenient to work directly on it, VNC could solve this use case. VNC is a graphical desktop sharing system for remotely controlling one computer's desktop interface (VNC server) from another computer or mobile device (VNC viewer). We can use RealVNC on Raspberry Pi OS, which has both VNC Server and VNC Viewer. VNC Server must be enabled before usage. In some cases, if the Raspberry Pi is headless, VNC allows us to get the GUI-access to it. For VNC configuration we need: Enable VNC server on command line with raspi-config: $ sudo raspi config VNC Server \u2192 Interfaces \u2192 VNC \u2192 Yes There are two ways to connect to your Raspberry Pi. You can use one or both depending on what works best for you. Establishment of a direct connection or a cloud connection. Direct Connection In case of the direct connection, we should get the IP address of the Raspberry Pi.Download VNC Viewer on the device you are using to take control. For best results, use RealVNC's compatible app. Enter the private IP address of your Raspberry Pi into VNC Viewer. Cloud Connection Sign up for a RealVNC account here: link . It's free and only takes a few seconds. On the Raspberry Pi, user must log in to VNC Server with the new RealVNC account credentials. Subsequently user must download VNC Viewer on the device you are using to take control. There must be RealVNC's compatible app. Then just sign in to VNC Viewer using the same RealVNC account credentials, afterwards either tap or click to connect to the Raspberry Pi. In both casesfor establishing either a direct or cloud connection, user must authenticate with VNC Server.","title":"Raspberry Pi configuration"},{"location":"Raspberry%20Pi%20configuration/#configuration-raspberry-pi","text":"","title":"Configuration Raspberry Pi"},{"location":"Raspberry%20Pi%20configuration/#ssh-connection","text":"","title":"SSH Connection"},{"location":"Raspberry%20Pi%20configuration/#configuration-using-command-line","text":"To open the configuration tool on a Raspberry Pi, enter the following command line in the command prompt: $ sudo raspi config Scroll up and down using tab-key and arrows, navigate SSH then YES , then OK then click Finish .","title":"Configuration using command line:"},{"location":"Raspberry%20Pi%20configuration/#configuration-using-desktop","text":"Go to menu Preferences , choosing Raspberry Pi configuration . Then the corresponding GUI opens with setting options, you should select SSH via interface options and release the corresponding option. Images were taken from www.raspberrypi.org","title":"Configuration using desktop:"},{"location":"Raspberry%20Pi%20configuration/#configuration-using-systemctl","text":"$ sudo systemctl enable ssh $ sudo systemctl start ssh IP-address of Rapsberry Pi You'll need to write down your Raspberry Pi's IP address to connect to it later. The ifconfig command displays information about the current network status, including the IP address, or you can use hostname -I to display the IP addresses associated with the device. For connection with the Raspberry Pi you need to type in the following: $ sudo pi@<IP>","title":"Configuration using systemctl:"},{"location":"Raspberry%20Pi%20configuration/#wifi-connection","text":"The tool raspi-config is being used also for the configuration of the wireless network to various parts of the boot, login, and networking process, as well as some other system-level changes. Wireless LAN connection is also turned on via this application as well as SSH. The one can also configure country-specific WLAN connection via WLAN Country if it's needed.","title":"WiFi Connection"},{"location":"Raspberry%20Pi%20configuration/#vnc-on-raspberry-pi","text":"In case someone likes to work on Raspberry Pi from another device by remote control, or when it is not convenient to work directly on it, VNC could solve this use case. VNC is a graphical desktop sharing system for remotely controlling one computer's desktop interface (VNC server) from another computer or mobile device (VNC viewer). We can use RealVNC on Raspberry Pi OS, which has both VNC Server and VNC Viewer. VNC Server must be enabled before usage. In some cases, if the Raspberry Pi is headless, VNC allows us to get the GUI-access to it. For VNC configuration we need: Enable VNC server on command line with raspi-config: $ sudo raspi config VNC Server \u2192 Interfaces \u2192 VNC \u2192 Yes There are two ways to connect to your Raspberry Pi. You can use one or both depending on what works best for you. Establishment of a direct connection or a cloud connection.","title":"VNC on Raspberry Pi"},{"location":"Raspberry%20Pi%20configuration/#direct-connection","text":"In case of the direct connection, we should get the IP address of the Raspberry Pi.Download VNC Viewer on the device you are using to take control. For best results, use RealVNC's compatible app. Enter the private IP address of your Raspberry Pi into VNC Viewer.","title":"Direct Connection"},{"location":"Raspberry%20Pi%20configuration/#cloud-connection","text":"Sign up for a RealVNC account here: link . It's free and only takes a few seconds. On the Raspberry Pi, user must log in to VNC Server with the new RealVNC account credentials. Subsequently user must download VNC Viewer on the device you are using to take control. There must be RealVNC's compatible app. Then just sign in to VNC Viewer using the same RealVNC account credentials, afterwards either tap or click to connect to the Raspberry Pi. In both casesfor establishing either a direct or cloud connection, user must authenticate with VNC Server.","title":"Cloud Connection"},{"location":"Raspberry%20Pi/","text":"Raspberry Pi Setup step-by-step This document gives us a quick overview how to setup Raspberry Pi . For this you need the following tools such as Micro HDMI cable, USB keyboard & mouse, SD card (for RaspberryPi Zero up to 256 GB), LAN cable for the Ethernet connection. The tools mentioned are not a must, but an optimal set for the initial configuration of the RaspberryPi. Installation of RaspberryPi OS First of all, one has to install RaspberryPi Imager using the following link . Images were taken from www.raspberrypi.org The current version of the operating system should then be selected using the \"Choose button\" button. We see several possibilities, the optimal choice would be RaspberryPi OS (32 GB). Images were taken from www.raspberrypi.org Next you have to connect the SD card to the card reader and select it as a storage medium in the image program. Then you have to start with the actual flashing after pressing the \"Write\" button. Images were taken from www.raspberrypi.org This brings us to the initial setup of the Raspberry Pi.","title":"Raspberry Pi"},{"location":"Raspberry%20Pi/#raspberry-pi","text":"","title":"Raspberry Pi"},{"location":"Raspberry%20Pi/#setup-step-by-step","text":"This document gives us a quick overview how to setup Raspberry Pi . For this you need the following tools such as Micro HDMI cable, USB keyboard & mouse, SD card (for RaspberryPi Zero up to 256 GB), LAN cable for the Ethernet connection. The tools mentioned are not a must, but an optimal set for the initial configuration of the RaspberryPi.","title":"Setup step-by-step"},{"location":"Raspberry%20Pi/#installation-of-raspberrypi-os","text":"First of all, one has to install RaspberryPi Imager using the following link . Images were taken from www.raspberrypi.org The current version of the operating system should then be selected using the \"Choose button\" button. We see several possibilities, the optimal choice would be RaspberryPi OS (32 GB). Images were taken from www.raspberrypi.org Next you have to connect the SD card to the card reader and select it as a storage medium in the image program. Then you have to start with the actual flashing after pressing the \"Write\" button. Images were taken from www.raspberrypi.org This brings us to the initial setup of the Raspberry Pi.","title":"Installation of RaspberryPi OS"},{"location":"hardware/","text":"Hardware ChalkBot Hardware","title":"Hardware"},{"location":"hardware/#hardware","text":"ChalkBot Hardware","title":"Hardware"},{"location":"hardware/test/","text":"Test","title":"Test"},{"location":"hardware/test/#test","text":"","title":"Test"},{"location":"software/","text":"Software Chalkbot Software","title":"Software"},{"location":"software/#software","text":"Chalkbot Software","title":"Software"},{"location":"software/Gyro-Control/","text":"The gyroscope-control mainly uses the JavaScript eventlistener deviceorientation which returns alpha beta and gamma values. Depending on the devices orientation the movement instructions are calculatet for example like the following if the device is in portratit mode. if (beta > 105) { // For backward movemnt move += 2; // 2 } else if (beta > 0 && beta < 75) { // For forward movemnt move += 1; // 1 } if (gamma < -15 && gamma > -75) { // For left movement move += 3; // 3 4 5 } else if (gamma < 75 && gamma > 15) { // For right movement move += 6; // 6 7 8 } The calculated number represents one instruction set: 1. Forward 2. Backwards 3. Left 4. Forward and left 5. Backwards and left 6. Right 7. Forward and right 8. Backward and right Afterwards this value is put in a list which uses the Canvas control format [\"Gyro\", moveIntention, printing] and is send to the CanvasServer via HTTPRequest. The CanvasServer identifies based on the keyword Gyro if the instruction is such and calls the sendCommandsToRobot -function. Based on the instruction given it is then translated into ChalkBot command instructions and send to the ChalkBot. The image above presents the dataflow in a compact form.","title":"Gyro Control"},{"location":"software/How%20the%20simulator%20and%20canvas%20work/","text":"Since we learned how to use the simulator, I want to explain to you how the simulator and canvas work in the background. When you draw a line in the drawing area several small blue arrows (as seen in the picture below) are created on that line. The x and y coordinates of these are stored in an array and get sent to the simulator or real life ChalkBot when you hit SEND. ChalkBot will then drive along those points and print the line. Every line you draw in the canvas is scaled by 10 to the real world. If you want to change if the simulator or ChalkBot should receive the coordinates, open CanvasServer.py in the canvas directory and move the hash from one to the other. The scaling is also changeable in this function. SAVE TO FILE uses the same array of coordinates and just saves them to a file, the name of the file can be also changed in CanvasServer.py in the do_Post function as seen below. CLEAR CANVAS removes all drawn lines by using the clearRect function by the canvas API, it also resets the array with the coordinates, because they would still be stored in the array otherwise after removing the drawn lines. The scaling of the drawing area is done by the following code. We just create a second canvas element and just copy all parameters from the previous canvas and then scale the height and width by the given value. The scale by button is implemented like this: To load the saved file, we need to filter out the coordinates, that's done with the following code that removes all characters that are not important to draw the saved lines. Now the coordinates are just sent to the simulator in the same way they would have been if you drew the line in the drawing area.","title":"How the simulator and canvas work"},{"location":"software/How%20to%20use%20the%20ChalkBot%20simulator/","text":"In this documentation of my work on the ChalkBot software, I want to introduce how the simulation server and the canvas server work and also how to use the functions of ChalkBot. Since both servers are written in Python, you need to have python installed to use them. You also need to install three packages with the following command in both directories: Now you are ready to start both servers by using in the canvas directory and in the Simulation directory. Both servers now run on your local device and can be reached with your browser at 127.0.0.1:8800 for the canvas and 127.0.0.1:8080 for the simulation. It should look like this: Now let's get to the functions of canvas. You can draw a line or multiple lines using your mouse inside the red rectangle. When you hit \u201cSEND\u201d, the information is sent to the simulator and ChalkBot will print your drawn line. \u201cSIMULATE\u201d simulates ChalkBot in the canvas as a green square. In the case that you want to save your drawing to send it to ChalkBot in the simulation or to the real ChalkBot later, just hit \u201cSAVE TO FILE\u201d and your data is stored in a file called \"coords.json\" in the canvas directory. To load that file, you need to choose it on the bottom left. After you hit \u201cLoad\u201d your data is sent to the simulator. \u201cCLEAR CANVAS\u201d is useful when you want to erase your lines that you drew before and start from scratch. The last option is to scale the drawing area to another size by inputting a number and then pressing \u201cScale\u201d. To close both servers just hit Ctrl+C in both terminals.","title":"How to use the ChalkBot simulator"}]}